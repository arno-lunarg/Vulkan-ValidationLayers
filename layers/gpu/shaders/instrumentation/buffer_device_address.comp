// Copyright (c) 2024 The Khronos Group Inc.
// Copyright (c) 2024 Valve Corporation
// Copyright (c) 2024 LunarG, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// NOTE: This file doesn't contain any entrypoints and should be compiled with then new --no-link option for glslang

#version 450
#extension GL_GOOGLE_include_directive : enable
//#extension GL_EXT_buffer_reference : require
//#extension GL_EXT_buffer_reference_uvec2 : require
#if defined(GL_ARB_gpu_shader_int64)
#extension GL_ARB_gpu_shader_int64 : require
#else
#error No extension available for 64-bit integers.
#endif

// TODO: see if only including what we need makes a difference
#include "gpu_shaders_constants.h"

layout(set = kInstDefaultDescriptorSet, binding = kBindingInstAccessedBufferDeviceAddresses, std430) buffer AccessedBufferDeviceAddresses {
    int accessed_address_ranges_count;// number of elements to be scanned
    uint write_i;
    uint read_i;// unused in this shader
    uint _pad;
    uvec4 accessed_address_ranges[];// array
};


bool inst_buffer_device_address(
    const uint inst_num, 
    const uvec4 stage_info, 
    const uint64_t addr, 
    const uint access_byte_size,
    const uint access_instruction) {
    
    const uint uvec4_capacity = accessed_address_ranges.length();
    const uint write_pos = atomicAdd(write_i, 2u) % uvec4_capacity;
    
    uvec4 pack1 = uvec4(
        uint(addr),
        uint(addr >> 32u), 
        (access_byte_size & 0x7FFFFFFF) | (access_instruction == 62 /*spv::OpStore*/ ? 0x1 : 0x0),
        inst_num
    );

    accessed_address_ranges[write_pos] = pack1;
    accessed_address_ranges[write_pos + 1] = stage_info;

    atomicAdd(accessed_address_ranges_count, 1);

    return true;
}
